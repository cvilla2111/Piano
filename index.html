<!DOCTYPE html><html lang="en"><head><meta name="x-poe-datastore-behavior" content="local_only"><meta http-equiv="Content-Security-Policy" content="default-src 'self' 'unsafe-inline' 'unsafe-eval' data: blob: https://cdnjs.cloudflare.com https://cdn.jsdelivr.net https://code.jquery.com https://unpkg.com https://d3js.org https://threejs.org https://cdn.plot.ly https://stackpath.bootstrapcdn.com https://maps.googleapis.com https://cdn.tailwindcss.com https://ajax.googleapis.com https://kit.fontawesome.com https://cdn.datatables.net https://maxcdn.bootstrapcdn.com https://code.highcharts.com https://tako-static-assets-production.s3.amazonaws.com https://www.youtube.com https://fonts.googleapis.com https://fonts.gstatic.com https://pfst.cf2.poecdn.net https://puc.poecdn.net https://i.imgur.com https://wikimedia.org https://*.icons8.com https://*.giphy.com https://picsum.photos https://images.unsplash.com; frame-src 'self' https://www.youtube.com https://trytako.com; child-src 'self'; manifest-src 'self'; worker-src 'self'; upgrade-insecure-requests; block-all-mixed-content;">
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ChordFlow - Chord Progression Composer</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin="">
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;500;700;900&amp;family=Fira+Code:wght@300;400;500&amp;display=swap" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-dark: #0a0e27;
            --bg-medium: #151b3d;
            --bg-light: #1f2847;
            --accent-primary: #00ff88;
            --accent-secondary: #00d9ff;
            --accent-tertiary: #ff00ff;
            --text-primary: #e0e6ff;
            --text-secondary: #8892b8;
            --border-color: #2a3357;
            --shadow-glow: rgba(0, 255, 136, 0.3);
        }

        body {
            font-family: 'Fira Code', monospace;
            background: linear-gradient(135deg, var(--bg-dark) 0%, #0f1535 50%, var(--bg-medium) 100%);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        body::before {
            content: '';
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background:
                radial-gradient(circle at 20% 30%, rgba(0, 255, 136, 0.05) 0%, transparent 50%),
                radial-gradient(circle at 80% 70%, rgba(0, 217, 255, 0.05) 0%, transparent 50%);
            pointer-events: none;
            z-index: 0;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
            position: relative;
            z-index: 1;
        }

        header {
            text-align: center;
            margin-bottom: 30px;
            animation: fadeInDown 0.8s ease-out;
        }

        h1 {
            font-family: 'Orbitron', sans-serif;
            font-size: clamp(2rem, 5vw, 3.5rem);
            font-weight: 900;
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary), var(--accent-tertiary));
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 10px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }

        .subtitle {
            color: var(--text-secondary);
            font-size: 0.9rem;
            letter-spacing: 3px;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 20px;
            margin-bottom: 20px;
        }

        @media (max-width: 968px) {
            .main-grid {
                grid-template-columns: 1fr;
            }

            .panel:nth-child(1) {
                order: 2;
            }

            .panel:nth-child(2) {
                order: 1;
            }
        }

        .panel {
            background: rgba(31, 40, 71, 0.6);
            backdrop-filter: blur(10px);
            border: 1px solid var(--border-color);
            border-radius: 12px;
            padding: 20px;
            animation: fadeInUp 0.6s ease-out;
            animation-fill-mode: both;
        }

        .panel:nth-child(1) { animation-delay: 0.1s; }
        .panel:nth-child(2) { animation-delay: 0.2s; }

        .panel-header {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.1rem;
            color: var(--accent-primary);
            margin-bottom: 15px;
            padding-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .panel-header::before {
            content: '▸';
            color: var(--accent-secondary);
        }

        .chord-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(70px, 1fr));
            gap: 10px;
            margin-bottom: 20px;
        }

        .chord-btn {
            background: linear-gradient(135deg, var(--bg-medium), var(--bg-light));
            border: 2px solid var(--border-color);
            color: var(--text-primary);
            padding: 12px 8px;
            border-radius: 8px;
            font-family: 'Orbitron', sans-serif;
            font-size: 0.9rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
            overflow: hidden;
        }

        .chord-btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: radial-gradient(circle, var(--accent-primary), transparent);
            transform: translate(-50%, -50%);
            transition: width 0.4s, height 0.4s;
            opacity: 0;
        }

        .chord-btn:hover {
            border-color: var(--accent-primary);
            box-shadow: 0 0 20px var(--shadow-glow);
            transform: translateY(-2px);
        }

        .chord-btn:hover::before {
            width: 200px;
            height: 200px;
            opacity: 0.1;
        }

        .chord-btn:active {
            transform: translateY(0);
        }

        .progression-area {
            background: rgba(10, 14, 39, 0.5);
            border: 2px dashed var(--border-color);
            border-radius: 12px;
            padding: 20px;
            min-height: 200px;
        }

        .progression-list {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            margin-bottom: 15px;
        }

        .progression-chord {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: var(--bg-dark);
            padding: 15px 20px;
            border-radius: 10px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1.2rem;
            font-weight: 900;
            display: flex;
            align-items: center;
            gap: 10px;
            cursor: pointer;
            transition: all 0.3s ease;
            box-shadow: 0 4px 15px rgba(0, 255, 136, 0.3);
            position: relative;
        }

        .progression-chord:hover {
            transform: scale(1.05) rotate(-2deg);
            box-shadow: 0 6px 25px rgba(0, 255, 136, 0.5);
        }

        .progression-chord.playing {
            animation: pulse 0.5s ease-in-out;
            box-shadow: 0 0 30px var(--accent-primary), 0 0 60px var(--accent-secondary);
        }

        .progression-chord .remove {
            background: rgba(255, 0, 0, 0.8);
            color: white;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 16px;
            line-height: 1;
            transition: all 0.2s;
        }

        .progression-chord .remove:hover {
            background: red;
            transform: scale(1.2);
        }

        .empty-state {
            text-align: center;
            color: var(--text-secondary);
            padding: 40px 20px;
            font-size: 0.9rem;
        }

        .controls {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 15px;
            margin-bottom: 20px;
        }

        .control-group {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .control-label {
            font-size: 0.85rem;
            color: var(--accent-secondary);
            font-weight: 500;
            text-transform: uppercase;
            letter-spacing: 1px;
        }

        select, input[type="range"], input[type="number"] {
            background: var(--bg-medium);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 10px 16px;
            border-radius: 8px;
            font-family: 'Fira Code', monospace;
            font-size: 16px;
            transition: all 0.3s;
        }

        select:focus, input:focus {
            outline: none;
            border-color: var(--accent-primary);
            box-shadow: 0 0 15px var(--shadow-glow);
        }

        input[type="range"] {
            -webkit-appearance: none;
            height: 6px;
            background: linear-gradient(to right, var(--accent-primary), var(--accent-secondary));
            border-radius: 5px;
            outline: none;
            padding: 0;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
            box-shadow: 0 0 10px var(--shadow-glow);
            transition: all 0.3s;
        }

        input[type="range"]::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 20px var(--accent-primary);
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--accent-primary);
            cursor: pointer;
            box-shadow: 0 0 10px var(--shadow-glow);
            border: none;
        }

        .playback-controls {
            display: flex;
            gap: 15px;
            flex-wrap: wrap;
        }

        .btn {
            background: linear-gradient(135deg, var(--accent-primary), var(--accent-secondary));
            color: var(--bg-dark);
            border: none;
            padding: 15px 30px;
            border-radius: 10px;
            font-family: 'Orbitron', sans-serif;
            font-size: 1rem;
            font-weight: 700;
            cursor: pointer;
            transition: all 0.3s ease;
            text-transform: uppercase;
            letter-spacing: 1px;
            box-shadow: 0 4px 15px var(--shadow-glow);
            position: relative;
            overflow: hidden;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            width: 0;
            height: 0;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.3);
            transform: translate(-50%, -50%);
            transition: width 0.6s, height 0.6s;
        }

        .btn:hover::before {
            width: 300px;
            height: 300px;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 6px 25px var(--shadow-glow);
        }

        .btn:active {
            transform: translateY(-1px);
        }

        .btn-secondary {
            background: linear-gradient(135deg, var(--bg-medium), var(--bg-light));
            color: var(--text-primary);
            border: 2px solid var(--border-color);
        }

        .btn-danger {
            background: linear-gradient(135deg, #ff0055, #ff4488);
            box-shadow: 0 4px 15px rgba(255, 0, 85, 0.3);
        }

        .quality-toggle {
            display: flex;
            gap: 10px;
            align-items: center;
        }

        .quality-toggle label {
            display: flex;
            align-items: center;
            gap: 5px;
            cursor: pointer;
            padding: 8px 15px;
            background: var(--bg-medium);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            transition: all 0.3s;
            font-size: 0.85rem;
        }

        .quality-toggle input[type="checkbox"] {
            width: 18px;
            height: 18px;
            cursor: pointer;
        }

        .quality-toggle label:hover {
            border-color: var(--accent-primary);
        }

        .tempo-display {
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .tempo-value {
            font-family: 'Orbitron', sans-serif;
            font-size: 1.5rem;
            color: var(--accent-primary);
            font-weight: 700;
            min-width: 80px;
        }

        @keyframes fadeInDown {
            from {
                opacity: 0;
                transform: translateY(-30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes fadeInUp {
            from {
                opacity: 0;
                transform: translateY(30px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
            }
            50% {
                transform: scale(1.1);
            }
        }

        .status-bar {
            background: rgba(10, 14, 39, 0.8);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            padding: 12px 20px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            font-size: 0.85rem;
            color: var(--text-secondary);
            animation: fadeInUp 0.6s ease-out 0.3s both;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .status-indicator {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-secondary);
        }

        .status-indicator.active {
            background: var(--accent-primary);
            box-shadow: 0 0 10px var(--accent-primary);
            animation: blink 1.5s infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        @media (max-width: 768px) {
            .container {
                padding: 15px;
            }

            .chord-grid {
                grid-template-columns: repeat(auto-fill, minmax(60px, 1fr));
                gap: 8px;
            }

            .chord-btn {
                padding: 10px 6px;
                font-size: 0.8rem;
            }

            .progression-chord {
                padding: 12px 15px;
                font-size: 1rem;
            }

            .playback-controls {
                flex-direction: column;
            }

            .btn {
                width: 100%;
            }

            .status-bar {
                flex-direction: column;
                gap: 10px;
                align-items: flex-start;
            }
        }
    </style>
<script src="https://puc.poecdn.net/authenticated_preview_page/syncedState.3f7572448765332f3047.js"></script></head>
<body>
    <div class="container">
        <header>
            <h1>ChordFlow</h1>
            <p class="subtitle">Chord Progression Composer</p>
        </header>

        <div class="main-grid">
            <div class="panel">
                <div class="panel-header">Chord Palette</div>
                <div class="chord-grid" id="chordPalette"></div>

                <div class="panel-header" style="margin-top: 20px;">Style &amp; Settings</div>
                <div class="controls">
                    <div class="control-group">
                        <label class="control-label">Style</label>
                        <select id="styleSelect">
                            <option value="pop">Pop</option>
                            <option value="rock">Rock</option>
                            <option value="jazz">Jazz</option>
                            <option value="blues">Blues</option>
                            <option value="latin">Latin</option>
                            <option value="ballad">Ballad</option>
                        </select>
                    </div>
                    <div class="control-group">
                        <label class="control-label">Key</label>
                        <select id="keySelect">
                            <option value="C">C Major</option>
                            <option value="G">G Major</option>
                            <option value="D">D Major</option>
                            <option value="A">A Major</option>
                            <option value="E">E Major</option>
                            <option value="F">F Major</option>
                            <option value="Am">A Minor</option>
                            <option value="Em">E Minor</option>
                            <option value="Dm">D Minor</option>
                        </select>
                    </div>
                </div>
                <div class="quality-toggle">
                    <label>
                        <input type="checkbox" id="bassToggle" checked="">
                        Bass
                    </label>
                    <label>
                        <input type="checkbox" id="drumsToggle" checked="">
                        Drums
                    </label>
                    <label>
                        <input type="checkbox" id="arpeggioToggle">
                        Arpeggio
                    </label>
                </div>
            </div>

            <div class="panel">
                <div class="panel-header">Chord Progression</div>
                <div class="progression-area">
                    <div class="progression-list" id="progressionList">
                        <div class="empty-state">
                            Click chords from the palette to build your progression →
                        </div>
                    </div>
                </div>

                <div class="control-group" style="margin-top: 20px;">
                    <label class="control-label">Tempo</label>
                    <div class="tempo-display">
                        <input type="range" id="tempoSlider" min="60" max="180" value="120" style="flex: 1;">
                        <span class="tempo-value"><span id="tempoValue">120</span> BPM</span>
                    </div>
                </div>

                <div class="playback-controls" style="margin-top: 20px;">
                    <button class="btn" id="playBtn">▶ Play</button>
                    <button class="btn btn-secondary" id="stopBtn">■ Stop</button>
                    <button class="btn btn-danger" id="clearBtn">Clear All</button>
                </div>
            </div>
        </div>

        <div class="status-bar">
            <div class="status-item">
                <div class="status-indicator" id="statusIndicator"></div>
                <span id="statusText">Ready</span>
            </div>
            <div class="status-item">
                <span>Chords: <strong id="chordCount">0</strong></span>
            </div>
            <div class="status-item">
                <span>Duration: <strong id="duration">0s</strong></span>
            </div>
        </div>
    </div>

    <script>
        // Audio Context
        let audioContext;
        let isPlaying = false;
        let scheduledNodes = [];
        let playbackTimeouts = [];
        let pianoSampleC = null; // Will hold the C.wav AudioBuffer

        // Musical data
        const chordDefinitions = {
            'C': [261.63, 329.63, 392.00],
            'Dm': [293.66, 349.23, 440.00],
            'Em': [329.63, 392.00, 493.88],
            'F': [349.23, 440.00, 523.25],
            'G': [392.00, 493.88, 587.33],
            'Am': [440.00, 523.25, 659.25],
            'Bdim': [493.88, 587.33, 698.46],
            'C7': [261.63, 329.63, 392.00, 466.16],
            'Dm7': [293.66, 349.23, 440.00, 523.25],
            'Em7': [329.63, 392.00, 493.88, 587.33],
            'F maj7': [349.23, 440.00, 523.25, 622.25],
            'G7': [392.00, 493.88, 587.33, 698.46],
            'Am7': [440.00, 523.25, 659.25, 783.99],
            'Cmaj7': [261.63, 329.63, 392.00, 493.88],
            'D7': [293.66, 369.99, 440.00, 523.25],
            'E7': [329.63, 415.30, 493.88, 587.33],
            'A7': [440.00, 554.37, 659.25, 783.99],
            'B7': [493.88, 622.25, 739.99, 880.00]
        };

        const chordsByKey = {
            'C': ['C', 'Dm', 'Em', 'F', 'G', 'Am', 'Bdim', 'Cmaj7', 'G7', 'Am7', 'F maj7'],
            'G': ['G', 'Am', 'Bdim', 'C', 'D', 'Em', 'F#dim', 'G7', 'D7', 'Em7', 'Cmaj7'],
            'D': ['D', 'Em', 'F#m', 'G', 'A', 'Bm', 'C#dim', 'D7', 'A7', 'Bm7', 'Gmaj7'],
            'A': ['A', 'Bm', 'C#m', 'D', 'E', 'F#m', 'G#dim', 'A7', 'E7', 'F#m7', 'Dmaj7'],
            'E': ['E', 'F#m', 'G#m', 'A', 'B', 'C#m', 'D#dim', 'E7', 'B7', 'C#m7', 'Amaj7'],
            'F': ['F', 'Gm', 'Am', 'Bb', 'C', 'Dm', 'Edim', 'F maj7', 'C7', 'Dm7', 'Bb maj7'],
            'Am': ['Am', 'Bdim', 'C', 'Dm', 'Em', 'F', 'G', 'Am7', 'E7', 'Dm7', 'Cmaj7'],
            'Em': ['Em', 'F#dim', 'G', 'Am', 'Bm', 'C', 'D', 'Em7', 'B7', 'Am7', 'Gmaj7'],
            'Dm': ['Dm', 'Edim', 'F', 'Gm', 'Am', 'Bb', 'C', 'Dm7', 'A7', 'Gm7', 'F maj7']
        };

        const drumPatterns = {
            pop: { kick: [0, 2], snare: [1, 3], hihat: [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5] },
            rock: { kick: [0, 2, 2.5], snare: [1, 3], hihat: [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5] },
            jazz: { kick: [0, 2.5], snare: [1, 3], hihat: [0, 1, 2, 3] },
            blues: { kick: [0, 2], snare: [1, 3], hihat: [0, 1, 1.5, 2, 3, 3.5] },
            latin: { kick: [0, 1.5, 2.5], snare: [1, 3], hihat: [0, 0.5, 1, 1.5, 2, 2.5, 3, 3.5] },
            ballad: { kick: [0, 2], snare: [1, 3], hihat: [0, 1, 2, 3] }
        };

        // State
        let progression = ['C', 'Am', 'F', 'G'];
        let currentKey = 'C';
        let currentStyle = 'pop';
        let tempo = 120;

        // Initialize
        async function init() {
            audioContext = new (window.AudioContext || window.webkitAudioContext)();

            // Load the C.wav sample
            await loadPianoSample();

            updateChordPalette();
            setupEventListeners();
            updateUI();
        }

        async function loadPianoSample() {
            try {
                // Load the local C4 piano sample
                const sampleUrl = 'sounds/C4v12.wav';

                document.getElementById('statusText').textContent = 'Loading piano sample...';

                const response = await fetch(sampleUrl);
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }

                const arrayBuffer = await response.arrayBuffer();
                pianoSampleC = await audioContext.decodeAudioData(arrayBuffer);

                document.getElementById('statusText').textContent = 'Ready (Sample-based)';
                console.log('Piano sample loaded successfully!');
            } catch (error) {
                console.error('Failed to load piano sample:', error);
                document.getElementById('statusText').textContent = 'Ready (Synthesized)';
                // If sample loading fails, we'll fall back to synthesis
            }
        }

        function updateChordPalette() {
            const palette = document.getElementById('chordPalette');
            const chords = chordsByKey[currentKey] || chordsByKey['C'];

            palette.innerHTML = '';
            chords.forEach(chord => {
                const btn = document.createElement('button');
                btn.className = 'chord-btn';
                btn.textContent = chord;
                btn.onclick = () => addChord(chord);
                palette.appendChild(btn);
            });
        }

        function addChord(chord) {
            progression.push(chord);
            updateUI();
        }

        function removeChord(index) {
            progression.splice(index, 1);
            updateUI();
        }

        function updateUI() {
            const list = document.getElementById('progressionList');

            if (progression.length === 0) {
                list.innerHTML = '<div class="empty-state">Click chords from the palette to build your progression →</div>';
            } else {
                list.innerHTML = '';
                progression.forEach((chord, index) => {
                    const div = document.createElement('div');
                    div.className = 'progression-chord';
                    div.id = `chord-${index}`;
                    div.innerHTML = `
                        <span>${chord}</span>
                        <button class="remove" onclick="removeChord(${index})">×</button>
                    `;
                    list.appendChild(div);
                });
            }

            document.getElementById('chordCount').textContent = progression.length;
            const beatDuration = 60 / tempo * 4; // 4 beats per chord
            document.getElementById('duration').textContent = (progression.length * beatDuration).toFixed(1) + 's';
        }

        function setupEventListeners() {
            document.getElementById('playBtn').onclick = play;
            document.getElementById('stopBtn').onclick = stop;
            document.getElementById('clearBtn').onclick = () => {
                progression = [];
                updateUI();
            };

            document.getElementById('tempoSlider').oninput = (e) => {
                tempo = parseInt(e.target.value);
                document.getElementById('tempoValue').textContent = tempo;
                updateUI();
            };

            document.getElementById('keySelect').onchange = (e) => {
                currentKey = e.target.value;
                updateChordPalette();
            };

            document.getElementById('styleSelect').onchange = (e) => {
                currentStyle = e.target.value;
            };
        }

        function play() {
            if (progression.length === 0) return;
            if (isPlaying) return;

            isPlaying = true;
            scheduledNodes = [];
            playbackTimeouts = [];

            document.getElementById('statusIndicator').classList.add('active');
            document.getElementById('statusText').textContent = 'Playing...';

            const beatDuration = 60 / tempo;
            const chordDuration = beatDuration * 4; // 4 beats per chord
            let currentTime = audioContext.currentTime;

            progression.forEach((chordName, index) => {
                const chordFreqs = chordDefinitions[chordName] || chordDefinitions['C'];
                const startTime = currentTime + (index * chordDuration);

                // Highlight chord
                const timeout = setTimeout(() => {
                    if (!isPlaying) return;
                    document.querySelectorAll('.progression-chord').forEach(el => {
                        el.classList.remove('playing');
                    });
                    const chordEl = document.getElementById(`chord-${index}`);
                    if (chordEl) chordEl.classList.add('playing');
                }, (startTime - audioContext.currentTime) * 1000);
                playbackTimeouts.push(timeout);

                // Play chord tones
                if (document.getElementById('arpeggioToggle').checked) {
                    playArpeggio(chordFreqs, startTime, chordDuration, beatDuration);
                } else {
                    playChord(chordFreqs, startTime, chordDuration);
                }

                // Play bass
                if (document.getElementById('bassToggle').checked) {
                    playBass(chordFreqs[0] / 2, startTime, chordDuration, beatDuration);
                }

                // Play drums
                if (document.getElementById('drumsToggle').checked) {
                    playDrums(startTime, chordDuration, beatDuration);
                }
            });

            // Reset after completion
            const totalDuration = progression.length * chordDuration;
            const completionTimeout = setTimeout(() => {
                stop();
            }, totalDuration * 1000);
            playbackTimeouts.push(completionTimeout);
        }

        function playChord(frequencies, startTime, duration) {
            frequencies.forEach(freq => {
                playPianoNote(freq, startTime, duration, 0.15);
            });
        }

        function playPianoNote(frequency, startTime, duration, volume) {
            // If we have the piano sample, use it. Otherwise, fall back to synthesis.
            if (pianoSampleC) {
                playSampledPianoNote(frequency, startTime, duration, volume);
            } else {
                playSynthesizedPianoNote(frequency, startTime, duration, volume);
            }
        }

        function playSampledPianoNote(frequency, startTime, duration, volume) {
            // Calculate semitone offset from C4 (261.63 Hz)
            const C4_FREQUENCY = 261.63;
            const semitoneOffset = 12 * Math.log2(frequency / C4_FREQUENCY);

            // Create audio source from sample
            const source = audioContext.createBufferSource();
            source.buffer = pianoSampleC;

            // Create gain for volume control
            const gainNode = audioContext.createGain();

            // Apply envelope for more natural decay
            gainNode.gain.setValueAtTime(0, startTime);
            gainNode.gain.linearRampToValueAtTime(volume, startTime + 0.01);
            gainNode.gain.exponentialRampToValueAtTime(volume * 0.7, startTime + 0.1);
            gainNode.gain.exponentialRampToValueAtTime(0.001, startTime + duration);

            // Pitch shift using detune (in cents: 100 cents = 1 semitone)
            if (source.detune) {
                source.detune.value = semitoneOffset * 100;
            } else {
                // Fallback for older browsers
                source.playbackRate.value = Math.pow(2, semitoneOffset / 12);
            }

            // Connect audio graph
            source.connect(gainNode);
            gainNode.connect(audioContext.destination);

            // Play the note
            source.start(startTime);
            source.stop(startTime + duration);

            scheduledNodes.push({ source, gain: gainNode });
        }

        function playSynthesizedPianoNote(frequency, startTime, duration, volume) {
            // Ultra-realistic piano synthesis with advanced physical modeling techniques
            // (Fallback when sample isn't loaded)

            // Frequency-dependent inharmonicity (increases with pitch and harmonic number)
            const baseInharmonicity = 0.00012 + (frequency / 10000) * 0.0003;

            // Extended harmonic series with realistic amplitude curves
            const harmonics = [
                { ratio: 1.0, amplitude: 1.0 },       // Fundamental
                { ratio: 2.0, amplitude: 0.55 },      // 2nd harmonic
                { ratio: 3.0, amplitude: 0.35 },      // 3rd harmonic
                { ratio: 4.0, amplitude: 0.22 },      // 4th harmonic
                { ratio: 5.0, amplitude: 0.15 },      // 5th harmonic
                { ratio: 6.0, amplitude: 0.10 },      // 6th harmonic
                { ratio: 7.0, amplitude: 0.06 },      // 7th harmonic
                { ratio: 8.0, amplitude: 0.04 },      // 8th harmonic
                { ratio: 9.0, amplitude: 0.025 },     // 9th harmonic
                { ratio: 10.0, amplitude: 0.015 },    // 10th harmonic
                { ratio: 11.0, amplitude: 0.008 },    // 11th harmonic
                { ratio: 12.0, amplitude: 0.004 }     // 12th harmonic
            ];

            // Create audio processing chain
            const masterGain = audioContext.createGain();

            // Dynamic lowpass filter (brightness depends on velocity/volume)
            const brightnessFilter = audioContext.createBiquadFilter();
            brightnessFilter.type = 'lowpass';
            const baseCutoff = Math.min(12000, frequency * 8);
            brightnessFilter.frequency.value = baseCutoff * (0.5 + volume * 2); // Louder = brighter
            brightnessFilter.Q.value = 0.7;

            // Body resonance filter (simulates piano soundboard)
            const bodyFilter = audioContext.createBiquadFilter();
            bodyFilter.type = 'peaking';
            bodyFilter.frequency.value = 200 + (frequency / 10); // Resonance moves with pitch
            bodyFilter.Q.value = 1.5;
            bodyFilter.gain.value = 3;

            // Stereo panner with position based on pitch (lower = left, higher = right)
            const panner = audioContext.createStereoPanner();
            const pitchPosition = Math.max(-0.4, Math.min(0.4, (frequency - 300) / 1000));
            panner.pan.value = pitchPosition + (Math.random() - 0.5) * 0.15;

            // Simple convolver for subtle room ambience
            const convolver = audioContext.createConvolver();
            const reverbLength = audioContext.sampleRate * 0.5; // 0.5 second reverb
            const reverbBuffer = audioContext.createBuffer(2, reverbLength, audioContext.sampleRate);

            for (let channel = 0; channel < 2; channel++) {
                const channelData = reverbBuffer.getChannelData(channel);
                for (let i = 0; i < reverbLength; i++) {
                    channelData[i] = (Math.random() * 2 - 1) * Math.pow(1 - i / reverbLength, 3);
                }
            }
            convolver.buffer = reverbBuffer;

            const dryGain = audioContext.createGain();
            const wetGain = audioContext.createGain();
            dryGain.gain.value = 0.85;
            wetGain.gain.value = 0.15;

            // Add hammer thump (percussive transient noise)
            const noise = audioContext.createBufferSource();
            const noiseBuffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.01, audioContext.sampleRate);
            const noiseData = noiseBuffer.getChannelData(0);
            for (let i = 0; i < noiseBuffer.length; i++) {
                noiseData[i] = (Math.random() * 2 - 1) * Math.exp(-i / (noiseBuffer.length * 0.1));
            }
            noise.buffer = noiseBuffer;

            const noiseFilter = audioContext.createBiquadFilter();
            noiseFilter.type = 'bandpass';
            noiseFilter.frequency.value = frequency * 2;
            noiseFilter.Q.value = 3;

            const noiseGain = audioContext.createGain();
            noiseGain.gain.setValueAtTime(volume * 0.15, startTime);
            noiseGain.gain.exponentialRampToValueAtTime(0.001, startTime + 0.015);

            noise.connect(noiseFilter);
            noiseFilter.connect(noiseGain);
            noiseGain.connect(brightnessFilter);
            noise.start(startTime);

            scheduledNodes.push({ source: noise, gain: noiseGain, filter: noiseFilter });

            // Generate harmonic oscillators
            harmonics.forEach((h, index) => {
                // Sophisticated inharmonicity calculation
                const inharmonicRatio = h.ratio * Math.sqrt(1 + baseInharmonicity * Math.pow(h.ratio, 2.3));

                // Harmonic-dependent detuning (3 unison oscillators)
                [-4, 0, 4].forEach((detune) => {
                    const osc = audioContext.createOscillator();
                    const gain = audioContext.createGain();

                    osc.type = 'sine';
                    osc.frequency.value = frequency * inharmonicRatio;

                    // More random detuning for higher harmonics (natural behavior)
                    const randomDetune = (Math.random() - 0.5) * (1 + index * 0.3);
                    osc.detune.value = detune + randomDetune;

                    const amp = volume * h.amplitude * 0.33;

                    // Harmonic-specific decay characteristics
                    const decayRate = 1 + (index * 0.4); // Higher harmonics decay faster
                    const attackVariation = Math.random() * 0.0008; // Slight timing variation
                    const attackTime = 0.001 + attackVariation;

                    // Complex multi-stage envelope
                    gain.gain.setValueAtTime(0, startTime);

                    // Percussive attack with overshoot (hammer strike)
                    gain.gain.linearRampToValueAtTime(amp * 1.3, startTime + attackTime);
                    gain.gain.exponentialRampToValueAtTime(amp * 1.05, startTime + attackTime + 0.003);

                    // Initial rapid decay
                    gain.gain.exponentialRampToValueAtTime(amp * 0.7, startTime + 0.06);

                    // Medium decay
                    gain.gain.exponentialRampToValueAtTime(amp * 0.45, startTime + 0.2);

                    // Sustain phase (slow decay)
                    gain.gain.exponentialRampToValueAtTime(amp * 0.25, startTime + duration * 0.4);

                    // Long release (harmonic-dependent)
                    const releaseTime = duration * (0.8 + index * 0.05);
                    gain.gain.exponentialRampToValueAtTime(0.001, startTime + releaseTime / decayRate);

                    osc.connect(gain);
                    gain.connect(brightnessFilter);

                    osc.start(startTime);
                    osc.stop(startTime + duration);

                    scheduledNodes.push({ osc, gain });
                });
            });

            // Dynamic brightness filter sweep (mimics string behavior)
            brightnessFilter.frequency.setValueAtTime(brightnessFilter.frequency.value, startTime);
            brightnessFilter.frequency.exponentialRampToValueAtTime(
                baseCutoff * 0.4,
                startTime + duration * 0.6
            );

            // Master gain envelope
            masterGain.gain.setValueAtTime(1, startTime);
            masterGain.gain.setValueAtTime(1, startTime + duration * 0.8);
            masterGain.gain.exponentialRampToValueAtTime(0.001, startTime + duration);

            // Connect the audio graph with parallel dry/wet routing
            // brightnessFilter -> bodyFilter -> split(dry/wet) -> panner -> masterGain -> destination
            brightnessFilter.connect(bodyFilter);
            bodyFilter.connect(dryGain);
            bodyFilter.connect(convolver);
            convolver.connect(wetGain);

            dryGain.connect(panner);
            wetGain.connect(panner);
            panner.connect(masterGain);
            masterGain.connect(audioContext.destination);

            scheduledNodes.push({
                gain: masterGain,
                filter: brightnessFilter,
                filter2: bodyFilter,
                panner,
                convolver,
                dryGain,
                wetGain
            });
        }

        function playArpeggio(frequencies, startTime, totalDuration, beatDuration) {
            const notePattern = [0, 2, 1, 2]; // Root, fifth, third, fifth
            const noteDuration = beatDuration;

            notePattern.forEach((noteIndex, i) => {
                const freq = frequencies[noteIndex % frequencies.length];
                const noteStart = startTime + (i * noteDuration);

                // Use the enhanced piano sound for arpeggio too
                playPianoNote(freq, noteStart, noteDuration * 0.8, 0.2);
            });
        }

        function playBass(frequency, startTime, totalDuration, beatDuration) {
            const pattern = [0, 0, 2, 3]; // Beat positions

            pattern.forEach(beat => {
                const noteStart = startTime + (beat * beatDuration);

                const osc = audioContext.createOscillator();
                const gain = audioContext.createGain();

                osc.type = 'sawtooth';
                osc.frequency.value = frequency;

                gain.gain.setValueAtTime(0, noteStart);
                gain.gain.linearRampToValueAtTime(0.3, noteStart + 0.01);
                gain.gain.exponentialRampToValueAtTime(0.01, noteStart + beatDuration * 0.7);

                osc.connect(gain);
                gain.connect(audioContext.destination);

                osc.start(noteStart);
                osc.stop(noteStart + beatDuration);

                scheduledNodes.push({ osc, gain });
            });
        }

        function playDrums(startTime, totalDuration, beatDuration) {
            const pattern = drumPatterns[currentStyle];

            // Kick drum
            pattern.kick.forEach(beat => {
                playDrum('kick', startTime + (beat * beatDuration));
            });

            // Snare
            pattern.snare.forEach(beat => {
                playDrum('snare', startTime + (beat * beatDuration));
            });

            // Hi-hat
            pattern.hihat.forEach(beat => {
                playDrum('hihat', startTime + (beat * beatDuration));
            });
        }

        function playDrum(type, startTime) {
            const osc = audioContext.createOscillator();
            const gain = audioContext.createGain();
            const filter = audioContext.createBiquadFilter();

            if (type === 'kick') {
                osc.frequency.setValueAtTime(150, startTime);
                osc.frequency.exponentialRampToValueAtTime(40, startTime + 0.1);
                gain.gain.setValueAtTime(0.4, startTime);
                gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.3);
                osc.type = 'sine';
            } else if (type === 'snare') {
                osc.type = 'triangle';
                osc.frequency.value = 200;
                gain.gain.setValueAtTime(0.3, startTime);
                gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.2);

                const noise = audioContext.createBufferSource();
                const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.2, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < buffer.length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                noise.buffer = buffer;

                const noiseGain = audioContext.createGain();
                noiseGain.gain.setValueAtTime(0.2, startTime);
                noiseGain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.1);

                noise.connect(noiseGain);
                noiseGain.connect(audioContext.destination);
                noise.start(startTime);

                scheduledNodes.push({ source: noise, gain: noiseGain });
            } else if (type === 'hihat') {
                const noise = audioContext.createBufferSource();
                const buffer = audioContext.createBuffer(1, audioContext.sampleRate * 0.05, audioContext.sampleRate);
                const data = buffer.getChannelData(0);
                for (let i = 0; i < buffer.length; i++) {
                    data[i] = Math.random() * 2 - 1;
                }
                noise.buffer = buffer;

                filter.type = 'highpass';
                filter.frequency.value = 7000;

                gain.gain.setValueAtTime(0.1, startTime);
                gain.gain.exponentialRampToValueAtTime(0.01, startTime + 0.05);

                noise.connect(filter);
                filter.connect(gain);
                gain.connect(audioContext.destination);
                noise.start(startTime);

                scheduledNodes.push({ source: noise, gain, filter });
                return;
            }

            osc.connect(gain);
            gain.connect(audioContext.destination);
            osc.start(startTime);
            osc.stop(startTime + 0.3);

            scheduledNodes.push({ osc, gain });
        }

        function stop() {
            isPlaying = false;

            // Clear all timeouts
            playbackTimeouts.forEach(timeout => clearTimeout(timeout));
            playbackTimeouts = [];

            // Stop all scheduled audio nodes
            const now = audioContext.currentTime;
            scheduledNodes.forEach(node => {
                try {
                    if (node.osc) {
                        node.osc.stop(now);
                    }
                    if (node.source) {
                        node.source.stop(now);
                    }
                    if (node.gain) {
                        node.gain.gain.cancelScheduledValues(now);
                        node.gain.gain.setValueAtTime(0, now);
                    }
                } catch (e) {
                    // Node might already be stopped
                }
            });
            scheduledNodes = [];

            // Update UI
            document.getElementById('statusIndicator').classList.remove('active');
            document.getElementById('statusText').textContent = 'Ready';
            document.querySelectorAll('.progression-chord').forEach(el => {
                el.classList.remove('playing');
            });
        }

        // Start the app
        window.onload = init;
    </script>



</body></html>